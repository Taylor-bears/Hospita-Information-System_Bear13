# 最简单的单管理员账号注册审核机制

## 一、技术实现概览

**核心思路**：
- 用户注册后账号状态为"待审核"，无法登录
- 管理员登录后台查看待审核用户列表，点击通过/拒绝
- 审核通过后用户才能正常登录使用系统

---

## 二、数据库改动

### 1. 修改用户表（users）

在现有用户表添加一个字段：

```sql
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'pending';
-- 可选值: 'pending'(待审核), 'active'(已激活), 'rejected'(已拒绝)

-- 如果需要记录拒绝原因
ALTER TABLE users ADD COLUMN reject_reason TEXT;

-- 添加索引加速查询
CREATE INDEX idx_users_status ON users(status);
```

### 2. 管理员标识（简单方案）

**方案A：硬编码**
```sql
-- 在用户表添加角色字段
ALTER TABLE users ADD COLUMN role VARCHAR(20) DEFAULT 'user';
-- 值: 'user'(普通用户), 'admin'(管理员)

-- 手动将某个账号设为管理员
UPDATE users SET role = 'admin', status = 'active' WHERE email = 'admin@example.com';
```

**方案B：配置文件**
```javascript
// config.js
const ADMIN_EMAIL = 'admin@example.com';
```

---

## 三、后端改动

### 1. 注册接口修改

```javascript
// POST /api/auth/register
app.post('/api/auth/register', async (req, res) => {
  const { email, password, username } = req.body;
  
  // 检查邮箱是否已存在
  const existingUser = await db.query('SELECT id FROM users WHERE email = ?', [email]);
  if (existingUser.length > 0) {
    return res.status(400).json({ error: '邮箱已被注册' });
  }
  
  // 密码加密
  const passwordHash = await bcrypt.hash(password, 10);
  
  // 创建用户，默认状态为 pending
  await db.query(
    'INSERT INTO users (email, password_hash, username, status, role) VALUES (?, ?, ?, ?, ?)',
    [email, passwordHash, username, 'pending', 'user']
  );
  
  res.status(201).json({ 
    message: '注册成功，请等待管理员审核',
    status: 'pending'
  });
});
```

### 2. 登录接口修改

```javascript
// POST /api/auth/login
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // 查询用户
  const users = await db.query('SELECT * FROM users WHERE email = ?', [email]);
  if (users.length === 0) {
    return res.status(401).json({ error: '邮箱或密码错误' });
  }
  
  const user = users[0];
  
  // 验证密码
  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) {
    return res.status(401).json({ error: '邮箱或密码错误' });
  }
  
  // ⭐ 检查账号状态
  if (user.status === 'pending') {
    return res.status(403).json({ 
      error: 'account_pending',
      message: '您的账号正在审核中，请耐心等待'
    });
  }
  
  if (user.status === 'rejected') {
    return res.status(403).json({ 
      error: 'account_rejected',
      message: '您的账号审核未通过',
      reason: user.reject_reason
    });
  }
  
  // 生成 token
  const token = jwt.sign(
    { userId: user.id, email: user.email, role: user.role },
    JWT_SECRET,
    { expiresIn: '7d' }
  );
  
  res.json({ 
    token,
    user: { id: user.id, email: user.email, username: user.username, role: user.role }
  });
});
```

### 3. 新增管理员审核接口

```javascript
// 中间件：验证管理员身份
const requireAdmin = (req, res, next) => {
  // 从 token 解析出的用户信息
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: '需要管理员权限' });
  }
  next();
};

// GET /api/admin/pending-users - 获取待审核用户列表
app.get('/api/admin/pending-users', authenticateToken, requireAdmin, async (req, res) => {
  const users = await db.query(
    'SELECT id, email, username, created_at FROM users WHERE status = ? ORDER BY created_at DESC',
    ['pending']
  );
  res.json({ users });
});

// POST /api/admin/users/:id/approve - 通过审核
app.post('/api/admin/users/:id/approve', authenticateToken, requireAdmin, async (req, res) => {
  const { id } = req.params;
  
  await db.query('UPDATE users SET status = ? WHERE id = ?', ['active', id]);
  
  // 可选：发送邮件通知用户
  // await sendEmail(user.email, '账号审核通过');
  
  res.json({ message: '审核通过' });
});

// POST /api/admin/users/:id/reject - 拒绝审核
app.post('/api/admin/users/:id/reject', authenticateToken, requireAdmin, async (req, res) => {
  const { id } = req.params;
  const { reason } = req.body; // 拒绝原因（可选）
  
  await db.query(
    'UPDATE users SET status = ?, reject_reason = ? WHERE id = ?',
    ['rejected', reason || '不符合注册要求', id]
  );
  
  res.json({ message: '已拒绝' });
});
```

### 4. 鉴权中间件（已有的话需要修改）

```javascript
const authenticateToken = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: '未登录' });
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded; // { userId, email, role }
    next();
  } catch (err) {
    return res.status(401).json({ error: 'token 无效' });
  }
};
```

---

## 四、前端改动

### 1. 注册页面（Register.jsx）

```jsx
const Register = () => {
  const [formData, setFormData] = useState({ email: '', password: '', username: '' });
  const [message, setMessage] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      const res = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      const data = await res.json();
      
      if (res.ok) {
        // ⭐ 显示待审核提示
        setMessage('注册成功！请等待管理员审核后登录');
      } else {
        setMessage(data.error);
      }
    } catch (err) {
      setMessage('注册失败');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" placeholder="邮箱" onChange={e => setFormData({...formData, email: e.target.value})} />
      <input type="password" placeholder="密码" onChange={e => setFormData({...formData, password: e.target.value})} />
      <input type="text" placeholder="用户名" onChange={e => setFormData({...formData, username: e.target.value})} />
      <button type="submit">注册</button>
      {message && <p>{message}</p>}
    </form>
  );
};
```

### 2. 登录页面（Login.jsx）

```jsx
const Login = () => {
  const [formData, setFormData] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      const data = await res.json();
      
      if (res.ok) {
        // 保存 token
        localStorage.setItem('token', data.token);
        localStorage.setItem('user', JSON.stringify(data.user));
        
        // 跳转到首页或管理后台
        if (data.user.role === 'admin') {
          navigate('/admin');
        } else {
          navigate('/dashboard');
        }
      } else {
        // ⭐ 处理审核状态错误
        if (data.error === 'account_pending') {
          setError('您的账号正在审核中，请耐心等待');
        } else if (data.error === 'account_rejected') {
          setError(`账号审核未通过：${data.reason || '请联系管理员'}`);
        } else {
          setError(data.message || '登录失败');
        }
      }
    } catch (err) {
      setError('网络错误');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" placeholder="邮箱" onChange={e => setFormData({...formData, email: e.target.value})} />
      <input type="password" placeholder="密码" onChange={e => setFormData({...formData, password: e.target.value})} />
      <button type="submit">登录</button>
      {error && <p style={{color: 'red'}}>{error}</p>}
    </form>
  );
};
```

### 3. 管理员审核页面（AdminReview.jsx）

```jsx
const AdminReview = () => {
  const [pendingUsers, setPendingUsers] = useState([]);
  const [rejectReason, setRejectReason] = useState({});

  useEffect(() => {
    fetchPendingUsers();
  }, []);

  const fetchPendingUsers = async () => {
    const token = localStorage.getItem('token');
    const res = await fetch('/api/admin/pending-users', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const data = await res.json();
    setPendingUsers(data.users);
  };

  const handleApprove = async (userId) => {
    const token = localStorage.getItem('token');
    await fetch(`/api/admin/users/${userId}/approve`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    // 刷新列表
    fetchPendingUsers();
    alert('审核通过');
  };

  const handleReject = async (userId) => {
    const token = localStorage.getItem('token');
    const reason = rejectReason[userId] || '';
    
    await fetch(`/api/admin/users/${userId}/reject`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ reason })
    });
    
    fetchPendingUsers();
    alert('已拒绝');
  };

  return (
    <div>
      <h2>待审核用户</h2>
      {pendingUsers.length === 0 ? (
        <p>暂无待审核用户</p>
      ) : (
        <table>
          <thead>
            <tr>
              <th>用户名</th>
              <th>邮箱</th>
              <th>注册时间</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody>
            {pendingUsers.map(user => (
              <tr key={user.id}>
                <td>{user.username}</td>
                <td>{user.email}</td>
                <td>{new Date(user.created_at).toLocaleString()}</td>
                <td>
                  <button onClick={() => handleApprove(user.id)}>通过</button>
                  <input 
                    type="text" 
                    placeholder="拒绝原因（可选）"
                    onChange={e => setRejectReason({...rejectReason, [user.id]: e.target.value})}
                  />
                  <button onClick={() => handleReject(user.id)}>拒绝</button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
};
```

### 4. 路由配置（App.jsx）

```jsx
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';

const PrivateRoute = ({ children, requireAdmin = false }) => {
  const token = localStorage.getItem('token');
  const user = JSON.parse(localStorage.getItem('user') || '{}');
  
  if (!token) return <Navigate to="/login" />;
  if (requireAdmin && user.role !== 'admin') return <Navigate to="/" />;
  
  return children;
};

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/register" element={<Register />} />
        <Route path="/login" element={<Login />} />
        
        <Route path="/dashboard" element={
          <PrivateRoute><Dashboard /></PrivateRoute>
        } />
        
        <Route path="/admin" element={
          <PrivateRoute requireAdmin={true}><AdminReview /></PrivateRoute>
        } />
      </Routes>
    </BrowserRouter>
  );
}
```

---

## 五、数据流向总结

```
┌─────────────┐
│  用户注册    │
└──────┬──────┘
       │
       ▼
┌─────────────────────────┐
│ 数据库 users 表          │
│ status = 'pending'      │
│ role = 'user'           │
└──────┬──────────────────┘
       │
       │ 管理员登录后台
       ▼
┌─────────────────────────┐
│ GET /api/admin/pending  │
│ 获取待审核列表           │
└──────┬──────────────────┘
       │
       │ 点击通过/拒绝
       ▼
┌─────────────────────────┐
│ POST /api/admin/.../    │
│ approve 或 reject       │
└──────┬──────────────────┘
       │
       ▼
┌─────────────────────────┐
│ 更新 users 表            │
│ status = 'active'       │
│ 或 'rejected'           │
└──────┬──────────────────┘
       │
       │ 用户尝试登录
       ▼
┌─────────────────────────┐
│ POST /api/auth/login    │
│ 检查 status 字段         │
│ - pending: 拒绝登录      │
│ - active: 签发 token    │
│ - rejected: 显示原因     │
└─────────────────────────┘
```

---

## 六、初始化管理员账号

在数据库中手动创建第一个管理员：

```sql
-- 假设密码是 'admin123'，先用 bcrypt 加密得到 hash
INSERT INTO users (email, password_hash, username, status, role, created_at) 
VALUES (
  'admin@example.com',
  '$2b$10$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', -- bcrypt hash
  'Admin',
  'active',
  'admin',
  NOW()
);
```

或者写个一次性脚本：

```javascript
// scripts/createAdmin.js
const bcrypt = require('bcrypt');
const db = require('./db');

async function createAdmin() {
  const passwordHash = await bcrypt.hash('admin123', 10);
  
  await db.query(
    'INSERT INTO users (email, password_hash, username, status, role) VALUES (?, ?, ?, ?, ?)',
    ['admin@example.com', passwordHash, 'Admin', 'active', 'admin']
  );
  
  console.log('管理员账号创建成功');
  process.exit(0);
}

createAdmin();
```

---

## 七、完整流程演示

1. **用户注册**
   - 访问 `/register`，填写信息提交
   - 后端创建用户，`status='pending'`
   - 前端显示"等待审核"

2. **用户尝试登录**
   - 访问 `/login`，输入账号密码
   - 后端检查 `status='pending'`，返回 403
   - 前端显示"账号审核中"

3. **管理员审核**
   - 管理员登录后访问 `/admin`
   - 看到待审核用户列表
   - 点击"通过"，后端更新 `status='active'`

4. **用户再次登录**
   - 访问 `/login`
   - 后端检查 `status='active'`，签发 token
   - 跳转到 `/dashboard`

---

## 八、注意事项

1. **安全**：
   - 密码必须用 bcrypt/argon2 加密
   - JWT_SECRET 要保密
   - 生产环境用 HTTPS

2. **体验优化**：
   - 注册后可发邮件通知管理员
   - 审核通过后可发邮件通知用户

3. **边界情况**：
   - 管理员自己的账号要预先设为 `active`
   - 防止管理员误操作把自己拒绝

这就是最简单的单管理员审核机制的完整实现！核心就是加一个 `status` 字段，在登录时检查状态，管理员通过接口修改状态。